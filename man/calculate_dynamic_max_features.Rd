% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/svmodt_dynamic_features.R
\name{calculate_dynamic_max_features}
\alias{calculate_dynamic_max_features}
\title{Dynamically determine the number of features to consider at a node}
\usage{
calculate_dynamic_max_features(
  data,
  response,
  base_max_features,
  depth,
  strategy = "constant",
  decrease_rate = 0.8,
  random_range = c(0.3, 1),
  verbose = FALSE
)
}
\arguments{
\item{data}{A data frame containing the predictor variables and the response variable.}

\item{response}{A character string specifying the name of the response variable
to exclude from the feature set.}

\item{base_max_features}{Integer; the base number of features to consider.
If `NULL`, all available features (excluding the response) are used.}

\item{depth}{Integer; the current depth of the node in the tree (used for
depth-dependent strategies).}

\item{strategy}{Character string specifying how to determine the number of
features. One of:
\itemize{
  \item `"constant"` – always use `base_max_features` (default).
  \item `"decrease"` – exponentially decrease the number of features with depth.
  \item `"random"` – randomly select the number of features within a range.
}}

\item{decrease_rate}{Numeric; factor (0–1] controlling how fast the number of
features decreases with depth when `strategy = "decrease"`. Default is 0.8.}

\item{random_range}{Numeric vector of length 2 specifying the lower and upper
bounds (as proportions of total features) for random selection when
`strategy = "random"`. Default is `c(0.3, 1.0)`.}

\item{verbose}{Logical; if `TRUE`, prints details about the chosen strategy
and resulting feature count.}
}
\value{
Integer; the number of features to consider at the current node.
  The value is always constrained between 1 and the total number of available features.
}
\description{
Computes the number of features to be used for splitting at a given tree depth
based on the specified strategy. Supports constant, decreasing, and random
feature selection strategies.
}
\details{
This function helps control model complexity and randomness by varying
the number of features used at each split.

Input parameters are validated to ensure sensible defaults. The result is capped
to avoid exceeding the total number of available features.
}
\examples{
\dontrun{
data <- data.frame(
  x1 = rnorm(100),
  x2 = rnorm(100),
  x3 = rnorm(100),
  y = sample(c("A", "B"), 100, TRUE)
)
calculate_dynamic_max_features(data, response = "y", base_max_features = 3,
                               depth = 2, strategy = "decrease", verbose = TRUE)
}

}
\keyword{internal}
